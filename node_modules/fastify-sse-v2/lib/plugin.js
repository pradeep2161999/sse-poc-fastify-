"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.plugin = void 0;

var _sse = require("./sse");

var _itToStream = _interopRequireDefault(require("it-to-stream"));

var _util = require("./util");

var _itPushable = _interopRequireDefault(require("it-pushable"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const plugin = async function (instance, options) {
  instance.decorateReply("sse", function (source) {
    //if this already set, it's not first event
    if (!this.raw.headersSent) {
      this.sseContext = {
        source: (0, _itPushable.default)()
      };
      Object.entries(this.getHeaders()).forEach(([key, value]) => {
        this.raw.setHeader(key, value);
      });
      this.raw.setHeader("Content-Type", "text/event-stream");
      this.raw.setHeader("Connection", "keep-alive");
      this.raw.setHeader("Cache-Control", "no-cache,no-transform");
      this.raw.setHeader("x-no-compression", 1);
      this.raw.write((0, _sse.serializeSSEEvent)({
        retry: options.retryDelay || 3000
      }));
      handleAsyncIterable(this, this.sseContext.source);
    }

    if ((0, _util.isAsyncIterable)(source)) {
      return handleAsyncIterable(this, source);
    } else {
      this.sseContext.source.push(source);
      return;
    }
  });
};

exports.plugin = plugin;

function handleAsyncIterable(reply, source) {
  (0, _itToStream.default)((0, _sse.transformAsyncIterable)(source)).pipe(reply.raw);
}
//# sourceMappingURL=plugin.js.map